const express = require('express');
const router = express.Router();
const User = require('../schema/userModel');
const Skill = require('../schema/userSkill');
const Role = require('../schema/role');
const equipmentModel = require('../schema/equipment');
const mongoose = require('mongoose');
const equipmentType = require('../schema/equipmentType');
const Bay = require('../schema/bay');
const DepartmentType = require('../schema/departmentType');
const { roleAuthPage, auth } = require('../middlewares');
const commonFunction = require('../public/js/commonFunction');
const taskModel = require('../schema/task');
const gateModel = require('../schema/gate');
const jwt = require('jsonwebtoken');
const nodemailer = require('nodemailer');
require('dotenv').config();
const companyModel = require('../schema/company');
const Task = require('../schema/task');
const wareHouse = require('../schema/warehouse');

/**
 * @swagger
 * /user/addNewUser:
 *   post:
 *     summary: Add New User
 *     tags: [User]
 *     description: Creates a new user with the specified details
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/AddNewUserRequest'
 *           example:
 *             firstName: "Cindrellaaa"
 *             lastName: "Sabestins"
 *             emailAddress: "cindrellaa@gmail.com"
 *             dateOfBirth: "2001-05-18"
 *             gender: "female"
 *             contactNumber: "9344623307"
 *             address: "kumbakonam"
 *             position: "firstLevel"
 *             department: "dev"
 *             supervisor: "test"
 *             startDate: "2023-06-30"
 *             employmentStatus: "ongoing"
 *             shiftSchedule: "1"
 *             salary_Rate: "20000"
 *             emergencyContact: "123456789"
 *             skills_Qualifications: "BE"
 *             trainingHistory: "level1"
 *             leaveHistory: "2"
 *             notes: "good"
 *             countryCode: "+1"
 *             mobile: "1234567890"
 *             password: "password123"
 *             role: "user"
 *             skillSet: ["Trally", "Hand Trucks", "Pallet Jack", "Forklift"]
 *             palletType: 1
 *     responses:
 *       200:
 *         description: User created successfully
 *       500:
 *         description: Internal server error
 *
 * components:
 *   schemas:
 *     AddNewUserRequest:
 *       type: object
 *       properties:
 *         firstName:
 *           type: string
 *           description: The first name of the user
 *         lastName:
 *           type: string
 *           description: The last name of the user
 *         fullName:
 *           type: string
 *           description: The full name of the user (automatically generated by combining the first name and last name)
 *         password:
 *           type: string
 *           description: The password for the user (automatically set to "123456")
 *         photoURL:
 *           type: string
 *           description: The URL of the user's profile picture
 *     ErrorResponse:
 *       type: object
 *       properties:
 *         status:
 *           type: integer
 *           description: The status code of the error response
 *         message:
 *           type: string
 *           description: The error message
 */

router.post('/addNewUserCopy', async (req, res) => {
  const reqBody = req.body;
  console.log("reqBody",reqBody)
  try {
    const existingUser = await User.findOne({ emailAddress: reqBody.emailAddress });
    if (existingUser) {
      return res.status(400).json({ status: -2, message: 'Email address already exists' });
    }
    reqBody.fullName = `${reqBody.firstName} ${reqBody.lastName}`;

    // Generate a random password of length 8 characters
    const cryptoRandomString = await import('crypto-random-string');
    const randomPassword = cryptoRandomString.default({ length: 8, type: 'alphanumeric' });
    reqBody.password = randomPassword;

    

    // Handling a single photoUrl
    if (reqBody.photoURL && reqBody.photoURL !== '') {
      const photoUrl = reqBody.photoURL;
      const photoUrlLength = photoUrl.split('/');
      if (photoUrlLength.length === 1) {
        const folderName = 'userDoc';
        commonFunction.moveToSingleDoc(reqBody.photoURL, folderName)
        // const movedPhotoUrl = await commonFunction.moveToSingleImage(reqBody.photoURL, 'profilePicture');
        reqBody.photoURL = 'userDoc/' + reqBody.photoURL;
      }
    } else {
      reqBody.photoURL = '';
    }

    if (Array.isArray(reqBody.documents) && reqBody.documents.length > 0) {
      const folderName = 'userDoc';
      const movedImageUrls = await Promise.all(reqBody.documents.map(imageName => commonFunction.moveToSingleDoc(imageName, folderName)));
      reqBody.documents = movedImageUrls;
    } else {
      reqBody.documents = [];
    }
    const userInfo = await User.findOne({ _id: reqBody.companyUserId }, { _id: 1, fullName: 1, email: 1, mobile: 1, countryCode: 1, country: 1, zipcode: 1, address: 1, state: 1, city: 1, companyInfo: 1 });
    reqBody.gateInfo = {};
    if (reqBody.gateId != undefined) {
      reqBody.gateInfo = await gateModel.findOne({ _id: reqBody.gateId });
    }
    reqBody.companyInfo = await companyModel.findOne({ _id: reqBody.companyId }, { _id: 1, name: 1, contactNumber: 1, email: 1 });
    reqBody.companyUserInfo = userInfo;
    // Save the user document to MongoDB
    const newUser = new User(reqBody);
    const result = await newUser.save();
    // console.log(result);
    // Send the generated password to the provided email address
    if (reqBody.emailAddress) {
      const transporter = nodemailer.createTransport({
        service: 'gmail',
        auth: {
          user: process.env.EMAILID,
          pass: process.env.PASSWORD,
        },
      });

      const mailOptions = {
        from: process.env.EMAILID,
        to: reqBody.emailAddress,
        subject: 'New User Registration',
        text: `Hello ${reqBody.fullName},\n\nYour account has been created successfully. Your password is: ${randomPassword}`
      };

      transporter.sendMail(mailOptions, (error, info) => {
        if (error) {
          console.error('Error sending email:', error);
          return res.status(500).json({ status: -1, message: 'Failed to send email' });
        } else {
          console.log('Email sent:', info.response);
          return res.status(200).json({ status: 1, message: 'User created successfully' });
        }
      });
    } else {
      return res.status(400).json({ status: -1, message: 'Email address not provided' });
    }
  // } catch (err) {
  //   console.log(err);
  //   return res.status(500).json({ status: -1, message: 'Internal error' });
  // }
  }catch (err) {
    console.log(err);
    if (err.code == 11000 && err.keyPattern && err.keyPattern.emailAddress ==1) {
      return res.status(400).json({ status: -2, message: 'Email address already exists' });
    }
    return res.status(500).json({ status: -1, message: 'Internal error' });
  }
});



router.post('/addNewUser', async (req, res) => {
  const reqBody = req.body;
  console.log("reqBody",reqBody)
  try {
    const existingUser = await User.findOne({ emailAddress: reqBody.emailAddress });
    if (existingUser) {
      return res.status(400).json({ status: -2, message: 'Email address already exists' });
    }
    reqBody.fullName = `${reqBody.firstName} ${reqBody.lastName}`;

    // Generate a random password of length 8 characters
    const cryptoRandomString = await import('crypto-random-string');
    const randomPassword = cryptoRandomString.default({ length: 8, type: 'alphanumeric' });
    reqBody.password = randomPassword;

    

    // Handling a single photoUrl
    if (reqBody.photoURL && reqBody.photoURL !== '') {
      const photoUrl = reqBody.photoURL;
      const photoUrlLength = photoUrl.split('/');
      if (photoUrlLength.length === 1) {
        const folderName = 'userDoc';
        commonFunction.moveToSingleDoc(reqBody.photoURL, folderName)
        // const movedPhotoUrl = await commonFunction.moveToSingleImage(reqBody.photoURL, 'profilePicture');
        reqBody.photoURL = 'userDoc/' + reqBody.photoURL;
      }
    } else {
      reqBody.photoURL = '';
    }


// Move equipmentLicense and idProof images to userDoc folder
if (reqBody.equipmentLicense) {
  const equipmentLicenseFolderName = 'userDoc';
  commonFunction.moveToSingleDoc(reqBody.equipmentLicense, equipmentLicenseFolderName);
} else {
  reqBody.equipmentLicense = ''; 
}

if (reqBody.idProof) {
  const idProofFolderName = 'userDoc';
  commonFunction.moveToSingleDoc(reqBody.idProof, idProofFolderName);
} else {
  reqBody.idProof = ''; 
}

    
    if (Array.isArray(reqBody.documents) && reqBody.documents.length > 0) {
      const folderName = 'userDoc';
      const movedImageUrls = await Promise.all(reqBody.documents.map(imageName => commonFunction.moveToSingleDoc(imageName, folderName)));
      reqBody.documents = movedImageUrls;
    } else {
      reqBody.documents = [];
    }
    const userInfo = await User.findOne({ _id: reqBody.companyUserId }, { _id: 1, fullName: 1, email: 1, mobile: 1, countryCode: 1, country: 1, zipcode: 1, address: 1, state: 1, city: 1, companyInfo: 1 });
    reqBody.gateInfo = {};
    if (reqBody.gateId != undefined) {
      reqBody.gateInfo = await gateModel.findOne({ _id: reqBody.gateId });
    }
    reqBody.companyInfo = await companyModel.findOne({ _id: reqBody.companyId }, { _id: 1, name: 1, contactNumber: 1, email: 1 });
    reqBody.companyUserInfo = userInfo;
    // Save the user document to MongoDB
    const newUser = new User(reqBody);
    const result = await newUser.save();
    // console.log(result);
    // Send the generated password to the provided email address
    if (reqBody.emailAddress) {
      const transporter = nodemailer.createTransport({
        service: 'gmail',
        auth: {
          user: process.env.EMAILID,
          pass: process.env.PASSWORD,
        },
      });

      const mailOptions = {
        from: process.env.EMAILID,
        to: reqBody.emailAddress,
        subject: 'New User Registration',
        text: `Hello ${reqBody.fullName},\n\nYour account has been created successfully. Your password is: ${randomPassword}`
      };

      transporter.sendMail(mailOptions, (error, info) => {
        if (error) {
          console.error('Error sending email:', error);
          return res.status(500).json({ status: -1, message: 'Failed to send email' });
        } else {
          console.log('Email sent:', info.response);
          return res.status(200).json({ status: 1, message: 'User created successfully' });
        }
      });
    } else {
      return res.status(400).json({ status: -1, message: 'Email address not provided' });
    }
  // } catch (err) {
  //   console.log(err);
  //   return res.status(500).json({ status: -1, message: 'Internal error' });
  // }
  }catch (err) {
    console.log(err);
    if (err.code == 11000 && err.keyPattern && err.keyPattern.emailAddress ==1) {
      return res.status(400).json({ status: -2, message: 'Email address already exists' });
    }
    return res.status(500).json({ status: -1, message: 'Internal error' });
  }
});



// listUser
/**
 * @swagger
 * /user/listUser:
 *   post:
 *     summary: List users
 *     tags: [User]
 *     description: "Status -1 => validation missing || Status 1 =>success"
 *     responses:
 *       200:
 *         description: Successful response
 *       500:
 *         description: Internal server error
 */

/**
 * @swagger
 * components:
 *   schemas:
 *     UserListResponse:
 *       type: object
 *       properties:
 *         status:
 *           type: number
 *           description: The status code (1 for success)
 *         message:
 *           type: string
 *           description: The message corresponding to the status
 *         responseData:
 *           type: array
 *           description: List of user objects
 *           items:
 *             $ref: '#/components/schemas/User'
 *       example:
 *         status: 1
 *         message: Success
 *         responseData:
 *           - name: John Doe
 *             email: johndoe@example.com
 *             countryCode: "+1"
 *             mobile: "1234567890"
 *             role: admin
 *           - name: Jane Smith
 *             email: janesmith@example.com
 *             countryCode: "+1"
 *             mobile: "9876543210"
 *             role: user
 *
 *     User:
 *       type: object
 *       properties:
 *         name:
 *           type: string
 *           description: The name of the user
 *         email:
 *           type: string
 *           description: The email address of the user
 *         countryCode:
 *           type: string
 *           description: The country code of the user's mobile number
 *         mobile:
 *           type: string
 *           description: The mobile number of the user
 *         status:
 *           type: number
 *           description: The status code (1 for active)
 *         role:
 *           type: string
 *           description: The role of the user
 *       example:
 *         name: John Doe
 *         email: johndoe@example.com
 *         countryCode: "+1"
 *         mobile: "1234567890"
 *         role: admin
 *
 *     ErrorResponse:
 *       type: object
 *       properties:
 *         status:
 *           type: number
 *           description: The status code (-1 for internal error)
 *         message:
 *           type: string
 *           description: The error message
 *       example:
 *         status: -1
 *         message: Internal error
 */


// router.post('/listUser', auth, roleAuthPage, async (req, res)
router.post('/listUser', async (req, res) => {
  const reqQuery = req.query;
  try {
    const reqBody = req.body;
    var filter = {};

    if (reqBody.status != undefined && reqBody.status != "") {
      filter.status = parseInt(reqBody.status);
    }
    // if (reqBody.companyUserId != undefined && reqBody.companyUserId != "") {
    //   filter['companyUserInfo._id'] = new mongoose.Types.ObjectId(reqBody.companyUserId);
    // }
    if (reqBody.wareHouseId != undefined && reqBody.wareHouseId != "") {
      filter.wareHouseId = new mongoose.Types.ObjectId(reqBody.wareHouseId);
    }
    if (reqBody.companyId != undefined && reqBody.companyId != "") {
      filter.companyId = new mongoose.Types.ObjectId(reqBody.companyId);
    }
    if (reqBody.department != undefined && reqBody.department != "") {
      filter['department.name'] = reqBody.department;
    }
    if (reqBody.search != undefined && reqBody.search != "") {
      const searchRegex = new RegExp(reqBody.search, 'i');
      filter.$or = [
        { name: searchRegex },
        { contactNumber: searchRegex },
        { emailAddress: searchRegex }
      ];
    }
    // console.log("filter", filter);
    var result = await User.find(filter, 'firstName lastName fullName dateOfBirth gender contactNumber address position department supervisor employmentStatus  emergencyContact skills qualifications trainingHistory leaveHistory notes emailAddress countryCode mobile status role uniqueId');
    // console.log("result",result);
    var presentCount = 0;
    var absentCount = 0;
    result.forEach(element => {
      if (element.status == 0) {
        absentCount += 1;
      } else {
        presentCount += 1;
      }
    });
    return res.status(200).json({ status: 1, message: commonFunction.translate('##success##', reqQuery.language), absentCount: absentCount, presentCount: presentCount, responseData: result });
  } catch (err) {
    console.log(err);
    return res.status(500).json({ status: -1, message: commonFunction.translate('##internal error##', reqQuery.language) });
  }
});


//getUserDetails
/**
 * @swagger
 * /user/getUserDetails:
 *   post:
 *     summary: Get user details
 *     tags: [User]
 *     description: "Status -1 => data not found|| Status 1 =>success"
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/UserDetailsRequest'
 *     responses:
 *       200:
 *         description: Successful response
 *       400:
 *         description: Data not found
 *       500:
 *         description: Internal server error
 */

/**
 * @swagger
 * components:
 *   schemas:
 *     UserDetailsRequest:
 *       type: object
 *       properties:
 *         id:
 *           type: string
 *           description: The ID of the user
 *       example:
 *         id: "64903b358d454b6653d393bf"
 *
 *     UserDetailsResponse:
 *       type: object
 *       properties:
 *         status:
 *           type: number
 *           description: The status code (1 for success)
 *         message:
 *           type: string
 *           description: The message corresponding to the status
 *         responseData:
 *           $ref: '#/components/schemas/User'
 *       example:
 *         status: 1
 *         message: Success
 *         responseData:
 *           name: John Doe
 *           email: johndoe@example.com
 *           countryCode: "+1"
 *           mobile: "1234567890"
 *           status: 1
 *           role: admin
 *
 *     ErrorResponse:
 *       type: object
 *       properties:
 *         status:
 *           type: number
 *           description: The status code (-1 for internal error)
 *         message:
 *           type: string
 *           description: The error message
 *       example:
 *         status: -1
 *         message: Internal error
 *
 *     User:
 *       type: object
 *       properties:
 *         name:
 *           type: string
 *           description: The name of the user
 *         email:
 *           type: string
 *           description: The email address of the user
 *         countryCode:
 *           type: string
 *           description: The country code of the user's mobile number
 *         mobile:
 *           type: string
 *           description: The mobile number of the user
 *         status:
 *           type: number
 *           description: The status code (1 for active)
 *         role:
 *           type: string
 *           description: The role of the user
 *       example:
 *         name: John Doe
 *         email: johndoe@example.com
 *         countryCode: "+1"
 *         mobile: "1234567890"
 *         role: admin
 */


router.post('/getUserDetails', async (req, res) => {
  const reqBody = req.body;
  const reqQuery = req.query;
  try {
    const result = await User.findOne({ _id: reqBody._id }).select('firstName lastName fullName dateOfBirth gender contactNumber address position department supervisor employmentStatus  emergencyContact skills qualifications trainingHistory leaveHistory notes emailAddress countryCode mobile status role equipmentType department qualification startDate bayInfo gateInfo uniqueId');
    if (result === null) {
      return res.status(400).json({ status: -1, message: commonFunction.translate('##data not found##', reqQuery.language) });
    }
    const taskDetails = await taskModel.find({ userId: reqBody._id });
    if (result.dateOfBirth!=undefined && result.dateOfBirth !="") {
      const inputDate = result.dateOfBirth;
      const dateObject = new Date(inputDate);
      result.dateOfBirth = dateObject.toISOString().split('T')[0];  
    }
    
    return res.status(200).json({ status: 1, message: commonFunction.translate('##success##', reqQuery.language), responseData: result, taskDetails: taskDetails });
  } catch (err) {
    return res.status(500).json({ status: -1, message: commonFunction.translate('##internal error##', reqQuery.language) });
  }
});

//login
/**
 * @swagger
 * /user/login:
 *   post:
 *     summary: User login
 *     tags: [User]
 *     description: Authenticate user and generate access and refresh tokens
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/LoginRequest'
 *     responses:
 *       200:
 *         description: Successful response
 *       400:
 *         description: Invalid mobile number or password mismatch
 *       500:
 *         description: Internal server error
 */

/**
 * @swagger
 * components:
 *   schemas:
 *     LoginRequest:
 *       type: object
 *       properties:
 *         mobile:
 *           type: string
 *           description: The email id of the user
 *         countryCode:
 *           type: string
 *           description: The country code of the user's mobile number
 *         password:
 *           type: string
 *           description: The password of the user
 *       example:
 *         emailAddress: "johndoe@example.com"
 *         password: "secretpassword"
 *
 *     LoginResponse:
 *       type: object
 *       properties:
 *         status:
 *           type: number
 *           description: The status code (1 for success)
 *         message:
 *           type: string
 *           description: The message corresponding to the status
 *         accessToken:
 *           type: string
 *           description: The access token for authentication
 *         refreshToken:
 *           type: string
 *           description: The refresh token for generating new access tokens
 *       example:
 *         status: 1
 *         message: Success
 *         accessToken: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
 *         refreshToken: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
 *
 *     ErrorResponse:
 *       type: object
 *       properties:
 *         status:
 *           type: number
 *           description: The status code (-1 for internal error, -2 for invalid email id or password mismatch)
 *         message:
 *           type: string
 *           description: The error message
 *       example:
 *         status: -1
 *         message: Internal error
 */


router.post('/login', async (req, res) => {
  const reqBody = req.body;
  const reqQuery = req.query;

  try {
    // email check
    const userInfo = await User.findOne({ emailAddress: reqBody.emailAddress });

    if (!userInfo) {
      return res.status(400).json({ status: -1, message: commonFunction.translate('##email is invalid##', reqQuery.language) });
    }

    // password check
    if (reqBody.password !== userInfo.password) {
      return res.status(400).json({ status: -2, message: commonFunction.translate('##password not match##', reqQuery.language) });
    }

    const refreshToken = jwt.sign({ userId: userInfo._id, role: userInfo.role }, process.env.REFRESHTOKEN);
    const refreshUser = jwt.verify(refreshToken, process.env.REFRESHTOKEN);
    const accessToken = jwt.sign({ userId: refreshUser.userId, role: userInfo.role }, process.env.ACCESSTOKEN, { expiresIn: '30m' });

    const updateUser = await User.updateOne({ _id: userInfo._id }, { $set: { deviceToken: req.body.deviceToken } });
    console.log("updateUser", updateUser);

    const responseData = {
      _id: userInfo._id,
      fullName: userInfo.fullName,
      emailAddress: userInfo.emailAddress,
      countryCode: userInfo.countryCode,
      mobile: userInfo.mobile,
      role: userInfo.role
    };

    return res.status(200).json({
      status: 1,
      message: commonFunction.translate('##login success##', reqQuery.language),
      accessToken: accessToken,
      refreshToken: refreshToken,
      responseData: responseData
    });
  } catch (err) {
    return res.status(500).json({ status: -1, message: commonFunction.translate('##internal error##', reqQuery.language) });
  }
});

// router.post('/loginWeb', async (req, res) => {
//   const reqBody = req.body;
//   const reqQuery = req.query;

//   //1->inboundflow,2->gatesecurity

//   try {
//     // email check
//     const userInfo = await User.findOne({ emailAddress: reqBody.emailAddress });

//     if (!userInfo) {
//       return res.status(400).json({ status: -1, message: commonFunction.translate('##email is invalid##', reqQuery.language) });
//     }

//     // password check
//     if (reqBody.password !== userInfo.password) {
//       return res.status(400).json({ status: -2, message: commonFunction.translate('##password not match##', reqQuery.language) });
//     }

//     const refreshToken = jwt.sign({ userId: userInfo._id, role: userInfo.role }, process.env.REFRESHTOKEN);
//     const refreshUser = jwt.verify(refreshToken, process.env.REFRESHTOKEN);
//     const expiresIn = 3 * 24 * 60 * 60;
//     const accessToken = jwt.sign({ userId: refreshUser.userId, role: userInfo.role }, process.env.ACCESSTOKEN, { expiresIn: expiresIn });
//     // if (reqBody.type!=undefined && reqBody.type=="Gate Security") {
//     //   if (userInfo.role!=undefined && userInfo.role.name!="Gate Security") {
//     //     return res.status(400).json({ status: -3, message: commonFunction.translate('##Invalid User##', reqQuery.language) });
//     //   }
//     // }
//     const responseData = {
//       _id: userInfo._id,
//       fullName: userInfo.fullName,
//       emailAddress: userInfo.emailAddress,
//       countryCode: userInfo.countryCode,
//       mobile: userInfo.mobile,
//       role: userInfo.role,
//       type: userInfo.type,
//       companyInfo: userInfo.companyInfo,
//       companyUserInfo: userInfo.companyUserInfo,
//       wareHouseId: userInfo.wareHouseId,
//       gateInfo: userInfo.gateInfo ? userInfo.gateInfo: {},
//     };

//     return res.status(200).json({
//       status: 1,
//       message: commonFunction.translate('##login success##', reqQuery.language),
//       accessToken: accessToken,
//       refreshToken: refreshToken,
//       responseData: responseData
//     });
//   } catch (err) {
//     return res.status(500).json({ status: -1, message: commonFunction.translate('##internal error##', reqQuery.language) });
//   }
// });

// function validatePasswordForType9(password) {
//   return password.length >= 6; 
// }


// router.post('/loginWeb', async (req, res) => {
//   const reqBody = req.body;
//   const reqQuery = req.query;
//   const type = reqBody.type;

//   //1->inboundflow,2->gatesecurity flow

//   try {
//     // email check
//     const userInfo = await User.findOne({ emailAddress: reqBody.emailAddress });

//     if (!userInfo) {
//       return res.status(400).json({ status: -1, message: commonFunction.translate('##email is invalid##', reqQuery.language) });
//     }


//     if (userInfo.type == 3) {
//       console.log("userInfo.role.type",userInfo.role.type);
//       if (type === 2) {
//         if (userInfo.role.type !== 9) {
//           return res.status(400).json({ status: -3, message: commonFunction.translate('##Invalid Access##', reqQuery.language) });
//         }
//       } else if (type === 1) {
//         if (userInfo.role.type == 9 || userInfo.role.type == 6 || userInfo.role.type == 7  || userInfo.role.type == 8) {
//           return res.status(400).json({ status: -4, message: commonFunction.translate('##Invalid Access##', reqQuery.language) });
//         }
//       }
//     }
//     // Regular password check for type 1
//     if (reqBody.password !== userInfo.password) {
//       return res.status(400).json({ status: -2, message: commonFunction.translate('##password not match##', reqQuery.language) });
//     }


//     const refreshToken = jwt.sign({ userId: userInfo._id, role: userInfo.role }, process.env.REFRESHTOKEN);
//     const refreshUser = jwt.verify(refreshToken, process.env.REFRESHTOKEN);
//     const expiresIn = 3 * 24 * 60 * 60;
//     const accessToken = jwt.sign({ userId: refreshUser.userId, role: userInfo.role }, process.env.ACCESSTOKEN, { expiresIn: expiresIn });
//     // if (reqBody.type!=undefined && reqBody.type=="Gate Security") {
//     //   if (userInfo.role!=undefined && userInfo.role.name!="Gate Security") {
//     //     return res.status(400).json({ status: -3, message: commonFunction.translate('##Invalid User##', reqQuery.language) });
//     //   }
//     // }
//     const responseData = {
//       _id: userInfo._id,
//       fullName: userInfo.fullName,
//       emailAddress: userInfo.emailAddress,
//       countryCode: userInfo.countryCode,
//       mobile: userInfo.mobile,
//       role: userInfo.role,
//       type: userInfo.type,
//       companyInfo: userInfo.companyInfo,
//       companyUserInfo: userInfo.companyUserInfo,
//       wareHouseId: userInfo.wareHouseId,
//       companyId: userInfo.companyId,
//       gateInfo: userInfo.gateInfo ? userInfo.gateInfo : {},
//     };

//     return res.status(200).json({
//       status: 1,
//       message: commonFunction.translate('##login success##', reqQuery.language),
//       accessToken: accessToken,
//       refreshToken: refreshToken,
//       responseData: responseData
//     });
//   } catch (err) {
//     console.log(err)
//     return res.status(500).json({ status: -1, message: commonFunction.translate('##internal error##', reqQuery.language) });
//   }
// });


router.post('/loginWeb', async (req, res) => {
  const reqBody = req.body;
  const reqQuery = req.query;
  const type = reqBody.type;

  // 1->inboundflow,2->gatesecurity flow

  try {
    // email check
    const userInfo = await User.findOne({ emailAddress: reqBody.emailAddress });

    if (!userInfo) {
      return res.status(400).json({ status: -1, message: commonFunction.translate('##email is invalid##', reqQuery.language) });
    }

    if (userInfo.type == 3) {
      console.log("userInfo.role.type", userInfo.role.type);
      if (type == 2) {
        if (userInfo.role.type !== 9) {
          return res.status(400).json({ status: -3, message: commonFunction.translate('##Invalid Access##', reqQuery.language) });
        }
      } else if (type == 1) {
        if (userInfo.role.type == 9 || userInfo.role.type == 6 || userInfo.role.type == 7 || userInfo.role.type == 8) {
          return res.status(400).json({ status: -4, message: commonFunction.translate('##Invalid Access##', reqQuery.language) });
        }
      }
    }

    // Regular password check for type 1
    if (reqBody.password !== userInfo.password) {
      return res.status(400).json({ status: -2, message: commonFunction.translate('##password not match##', reqQuery.language) });
    }

    const refreshToken = jwt.sign({ userId: userInfo._id, role: userInfo.role }, process.env.REFRESHTOKEN);
    const refreshUser = jwt.verify(refreshToken, process.env.REFRESHTOKEN);
    const expiresIn = 3 * 24 * 60 * 60;
    const accessToken = jwt.sign({ userId: refreshUser.userId, role: userInfo.role }, process.env.ACCESSTOKEN, { expiresIn: expiresIn });

    let responseData = {
      _id: userInfo._id,
      fullName: userInfo.fullName,
      emailAddress: userInfo.emailAddress,
      countryCode: userInfo.countryCode,
      mobile: userInfo.mobile,
      role: userInfo.role,
      type: userInfo.type,
      companyInfo: userInfo.companyInfo,
      companyUserInfo: userInfo.companyUserInfo,
      wareHouseId: userInfo.wareHouseId,
      companyId: userInfo.companyId,
      gateInfo: userInfo.gateInfo ? userInfo.gateInfo : {},
    };

   
    // Check if type is 3, then fetch and include the warehouse name
    console.log("userInfo.wareHouseId",userInfo.wareHouseId);
    if (userInfo.type == 3 && userInfo.wareHouseId) {
      console.log("if");
      const warehouse = await wareHouse.findOne({ _id: userInfo.wareHouseId });
      if (warehouse) {
        console.log("ifwlasw",warehouse);
        responseData = {
          ...responseData,
          wareHouseName: warehouse.name,
        };
      }
    } else {
      console.log("else");
      // Set wareHouseName to an empty string for type 1 or 2
      responseData = {
        ...responseData,
        wareHouseName: '',
      };
    }

    return res.status(200).json({
      status: 1,
      message: commonFunction.translate('##login success##', reqQuery.language),
      accessToken: accessToken,
      refreshToken: refreshToken,
      responseData: responseData
    });
  } catch (err) {
    console.log(err)
    return res.status(500).json({ status: -1, message: commonFunction.translate('##internal error##', reqQuery.language) });
  }
});




/**
 * @swagger
 * /user/skilsetWiseListEquipment:
 *   post:
 *     summary: User login
 *     tags: [User]
 *     description: Authenticate user and generate access token
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/LoginRequest'
 *           example:
 *             userId: "6491595a45c273046631b9f2"
 *     responses:
 *       200:
 *         description: Successful response
 */

/**
 * @swagger
 * components:
 *   schemas:
 *     Request:
 *       type: object
 *       properties:
 *         userId:
 *           type: string
 *           description: The user ID
 *       example:
 *         userId: "6491595a45c273046631b9f2"
 *     Response:
 *       type: object
 *       properties:
 *         status:
 *           type: number
 *           description: The status code (1 for success)
 *         message:
 *           type: string
 *           description: The message corresponding to the status
 *       example:
 *         status: 1
 *         message: Success
 *         responseData: [{"_id": "64915c978808412deef2303d","type": "Trally","name": "Trally-001","make": "2009","model": "new model","lastServiceDate": "2023-05-18","nextServiceDate": "2023-06-18","status": 0,"createdAt": "2023-06-20T08:00:23.749Z"}]
 *     ErrorResponse:
 *       type: object
 *       properties:
 *         status:
 *           type: number
 *           description: The status code (-1 for internal error)
 *         message:
 *           type: string
 *           description: The error message
 *       example:
 *         status: -1
 *         message: Internal error
 */

// skilset wise list the vehicle
router.post('/skilsetWiseListEquipment', async (req, res) => {
  const reqBody = req.body;
  const reqQuery = req.query;
  try {
    if (!reqBody.userId)
      return res.status(400).json({ status: -1, message: commonFunction.translate('##validation error##', reqQuery.language) });

    var userInfo = await User.findOne({ _id: reqBody.userId }, { skillSet: 1 });
    if (userInfo == null) {
      return res.status(400).json({ status: -2, message: commonFunction.translate('##user not found##', reqQuery.language) });
    }
    var equipmentType = userInfo.skillSet;
    var equipmentList = await equipmentModel.find({ type: { $in: equipmentType }, status: 0 });
    return res.status(200).json({ status: 1, message: commonFunction.translate('##success##', reqQuery.language), responseData: equipmentList });
  } catch (err) {
    return res.status(500).json({ status: -1, message: commonFunction.translate('##internal error##', reqQuery.language) });
  }
});

/**
 * @swagger
 * /user/palletTypeList:
 *   post:
 *     summary: Get users by pallet type
 *     tags: [User]
 *     description: Retrieve a list of users based on the specified pallet type
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/PalletTypeListRequest'
 *     responses:
 *       200:
 *         description: Successful response
 *       400:
 *         description: PalletType not found
 *       500:
 *         description: Internal server error
 */

/**
 * @swagger
 * components:
 *   schemas:
 *     PalletTypeListRequest:
 *       type: object
 *       properties:
 *         palletType:
 *           type: string
 *           description: The type of pallet
 *       example:
 *         palletType: 1
 *
 *     PalletTypeListResponse:
 *       type: object
 *       properties:
 *         status:
 *           type: number
 *           description: The status code (1 for success)
 *         message:
 *           type: string
 *           description: The message corresponding to the status
 *         responseData:
 *           type: array
 *           description: The list of users with the specified pallet type
 *           items:
 *             $ref: '#/components/schemas/User'
 *       example:
 *         status: 1
 *         message: Pallet type is listed
 *         responseData:
 *           - name: "John Doe"
 *             email: "john@example.com"
 *             palletType: "Type A"
 *             status: 1
 *           - name: "Jane Smith"
 *             email: "jane@example.com"
 *             palletType: "Type A"
 *             status: 1
 *
 *     User:
 *       type: object
 *       properties:
 *         name:
 *           type: string
 *           description: The name of the user
 *         email:
 *           type: string
 *           format: email
 *           description: The email address of the user
 *         palletType:
 *           type: string
 *           description: The type of pallet associated with the user
 *         status:
 *           type: number
 *           description: The status of the user
 *       example:
 *         palletType: 1
 *
 *     ErrorResponse:
 *       type: object
 *       properties:
 *         status:
 *           type: number
 *           description: The status code
 *         message:
 *           type: string
 *           description: The error message
 *       example:
 *         status: -1
 *         message: Internal server error
 */

router.post('/palletTypeList', async (req, res) => {
  const reqQuery = req.query;
  const palletType = req.body.palletType;
  try {
    const reqBody = req.body;
    // const users = await User.find({ palletType: reqBody.palletType, status: 1 }).select('firstName lastName fullName dateOfBirth gender contactNumber address position department supervisor employmentStatus  emergencyContact skills qualifications trainingHistory leaveHistory notes emailAddress countryCode mobile status role palletType');
    var users = await User.find({ skills: { $in: reqBody.palletType } }).select('firstName lastName fullName dateOfBirth gender contactNumber address position department supervisor employmentStatus  emergencyContact skills qualifications trainingHistory leaveHistory notes emailAddress countryCode mobile status role palletType');

    if (users.length === 0) {

      return res.status(400).json({ status: -1, message: commonFunction.translate('##pallettype not found##', reqQuery.language) });
    }


    return res.status(200).json({ status: 1, message: commonFunction.translate('##success##', reqQuery.language), responseData: users });
  } catch (err) {
    console.log("err", err);
    return res.status(500).json({ status: -1, message: commonFunction.translate('##internal error##', reqQuery.language) });
  }
});

/**
 * @swagger
 * /user/userByRole:
 *   post:
 *     summary: Get users by role
 *     tags: [User]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/UserByRoleRequest'
 *           example:
 *             role: "Employee"
 *     responses:
 *       200:
 *         description: Successful response
 *       400:
 *         description: User not found
 *       500:
 *         description: Internal server error
 */

/**
 * @swagger
 * components:
 *   schemas:
 *     UserByRoleRequest:
 *       type: object
 *       properties:
 *         role:
 *           type: string
 *           description: The role of the user
 *
 *     UserByRoleResponse:
 *       type: object
 *       properties:
 *         status:
 *           type: number
 *           description: The status code (1 for success, -1 for errors)
 *         message:
 *           type: string
 *           description: The response message
 *         responseData:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/UserInfo'
 *
 *     UserInfo:
 *       type: object
 *       properties:
 *         id:
 *           type: string
 *           description: The ID of the user
 *         name:
 *           type: string
 *           description: The name of the user
 *         email:
 *           type: string
 *           description: The email of the user
 *
 *     ErrorResponse:
 *       type: object
 *       properties:
 *         status:
 *           type: number
 *           description: The status code (-1 for errors)
 *         message:
 *           type: string
 *           description: The error message
 */


router.post('/userByRole', async (req, res) => {
  const reqQuery = req.query;
  const reqBody = req.body;
  try {
    const userList = await User.find({ 'role.id': reqBody.role, status: 1 }).select('firstName lastName fullName dateOfBirth gender contactNumber address position department supervisor employmentStatus  emergencyContact skills qualifications trainingHistory leaveHistory notes emailAddress countryCode mobile status role palletType');

    if (userList.length === 0) {
      return res.status(400).json({ status: -1, message: commonFunction.translate('##user not found##', reqQuery.language) });
    }
    return res.status(200).json({ status: 1, message: commonFunction.translate('##success##', reqQuery.language), responseData: userList });
  } catch (err) {

    return res.status(500).json({ status: -1, message: commonFunction.translate('##internal error##', reqQuery.language) });
  }
});



router.post('/forgotPassword', async (req, res) => {
  const { emailAddress } = req.body;
  try {

    const user = await User.findOne({ emailAddress });

    if (!user) {
      return res.status(404).json({ status: -1, message: 'User not found' });
    }


    const newPassword = generateRandomPassword(10);


    user.password = newPassword;

    await user.save();

    return res.status(200).json({ status: 1, message: 'Password reset successful', newPassword });
  } catch (error) {
    console.error('Error resetting password:', error);
    return res.status(500).json({ status: -1, message: 'Internal server error' });
  }
});


function generateRandomPassword(length) {
  const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  let password = '';
  for (let i = 0; i < length; i++) {
    const randomIndex = Math.floor(Math.random() * characters.length);
    password += characters[randomIndex];
  }
  return password;
}


// const nodemailer = require('nodemailer');

// router.post('/forgotPassword', async (req, res) => {
//   const { emailAddress } = req.body;

//   try {
//     const user = await User.findOne({ email });

//     if (!user) {
//       return res.status(404).json({ status: -1, message: 'User not found' });
//     }

//     const newPassword = generateRandomPassword(10);
//     user.password = newPassword;
//     await user.save();

//     // const transporter = nodemailer.createTransport({
//     //     host: 'smtp.example.com', // Replace with your SMTP server
//     //     port: 3002,
//     //     secure: false,
//     //     auth: {
//     //       user: 'cindrellasabestin@gmail.com', // Replace with your email address
//     //       pass: '7gE0mG5XFW', // Replace with your email password
//     //     },
//     //   });
//     var smtpTransport = nodemailer.createTransport("SMTP",{
//         service: "gmail",
//         auth: {
//             user: "cindrellasabestin@gmail.com",
//             pass: "Zz8rUJVwcl"
//         }
//     });

//       const mailOptions = {
//         from: 'cindrellasabestin@gmail.com', // Replace with your email address
//         to: email,
//         subject: 'Password Reset',
//         text: `Your new password is: ${newPassword}`,
//       };

//     transporter.sendMail(mailOptions, (error, info) => {
//       if (error) {
//         console.error('Error sending email:', error);
//         return res.status(500).json({ status: -1, message: 'Error sending email' });
//       }
//       console.log('Email sent:', info.response);
//       return res.status(200).json({ status: 1, message: 'Password reset successful' });
//     });
//   } catch (error) {
//     console.error('Error resetting password:', error);
//     return res.status(500).json({ status: -1, message: 'Internal server error' });
//   }
// });

// function generateRandomPassword(length) {
//   const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
//   let password = '';
//   for (let i = 0; i < length; i++) {
//     const randomIndex = Math.floor(Math.random() * characters.length);
//     password += characters[randomIndex];
//   }
//   return password;
// }

//update
/**
 * @swagger
 * /user/update:
 *   post:
 *     summary: Update a user
 *     tags: [User]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/UpdateUserRequest'
 *           example:
 *             _id: 12345
 *             name: John Doe
 *             email: johndoe@example.com
 *             age: 30
 *     responses:
 *       200:
 *         description: User updated successfully
 *       400:
 *         description: Validation error or user not found
 *       500:
 *         description: Internal server error
 *
 * components:
 *   schemas:
 *     UpdateUserRequest:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: The ID of the user to update
 *         name:
 *           type: string
 *           description: The updated name of the user
 *         email:
 *           type: string
 *           format: email
 *           description: The updated email of the user
 *         age:
 *           type: number
 *           description: The updated age of the user
 *     UpdateUserResponse:
 *       type: object
 *       properties:
 *         status:
 *           type: number
 *           description: The status code (1 for success)
 *         message:
 *           type: string
 *           description: The response message
 *         responseData:
 *           $ref: '#/components/schemas/User'
 *     ErrorResponse:
 *       type: object
 *       properties:
 *         status:
 *           type: number
 *           description: The status code (-1 for error)
 *         message:
 *           type: string
 *           description: The error message
 *     User:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: The ID of the user
 *         name:
 *           type: string
 *           description: The name of the user
 *         email:
 *           type: string
 *           format: email
 *           description: The email of the user
 *         age:
 *           type: number
 *           description: The age of the user
 */


router.post('/update', async (req, res) => {
  const reqQuery = req.query;
  try {
    if (!req.body._id) return res.status(400).json({ 'status': -1, 'message': commonFunction.translate('##validation error##', reqQuery.language) });
    req.body.gateInfo = {};
    if (req.body.gateId != undefined) {
      req.body.gateInfo = await gateModel.findOne({ _id: req.body.gateId });
    }
    const newUser = await User.findByIdAndUpdate(req.body._id, req.body, { new: true, runValidators: true });
    if (!newUser) {
      return res.status(400).json({ 'status': -2, 'message': commonFunction.translate('##gate not found##', reqQuery.language) });
    }
    return res.status(200).json({ 'status': 1, 'message': commonFunction.translate('##gate updated successfully##', reqQuery.language), responseData: newUser });
  } catch (error) {
    return res.status(500).json({ 'status': -1, 'message': commonFunction.translate('##internal server error##', reqQuery.language) });
  }
});

/**
 * @swagger
 * /user/delete:
 *   delete:
 *     summary: Delete User
 *     tags: [User]
 *     description: Deletes a user with the specified ID
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/DeleteUserRequest'
 *     responses:
 *       200:
 *         description: User deleted successfully
 *       400:
 *         description: Bad request or user not found
 *
 * components:
 *   schemas:
 *     DeleteUserRequest:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: The ID of the user to be deleted
 *       example:
 *         _id: "646dbc9e4cd7fe1b30d4e7e7"
 *     ErrorResponse:
 *       type: object
 *       properties:
 *         status:
 *           type: integer
 *           description: The status code of the error response
 *         message:
 *           type: string
 *           description: The error message
 */


router.delete('/delete', async (req, res) => {
  const reqQuery = req.query;
  try {
    if (!req.body._id) return res.status(400).json({ 'status': -1, 'message': commonFunction.translate('##validation error##', reqQuery.language) });

    const newUser = await User.findByIdAndDelete(req.body._id);
    if (!newUser) {
      return res.status(400).json({ 'status': -2, 'message': commonFunction.translate('##user not found##', reqQuery.language) });
    }
    return res.status(200).json({ 'status': 1, 'message': commonFunction.translate('##user deleted successfully##', reqQuery.language) });
  } catch (error) {
    return res.status(400).json({ 'status': -1, 'message': commonFunction.translate('##internal server error##', reqQuery.language) });
  }
});


router.post('/userGetCore', async (req, res) => {
  try {
    // Fetch data from collections
    const userRoleData = await Role.find({}, { _id: 1, name: 1, type: 1 });
    const skillsData = await Skill.find({}, { _id: 1, name: 1 });
    const inboundBays = await Bay.find({ groupId: 1 });
    const equipmentTypeData = await equipmentType.find({}, { _id: 1, name: 1 });
    const departmentTypeData = await DepartmentType.find({}, { _id: 1, name: 1 });

    // Prepare the response data
    const responseData = {
      userRole: userRoleData,
      skills: skillsData,
      equipmentType: equipmentTypeData,
      departmentType: departmentTypeData,
      inboundBays: inboundBays
    };

    return res.json({ status: 1, message: 'success', responseData });
  } catch (error) {
    console.error('Error fetching data:', error);
    return res.status(500).json({ status: 0, message: 'Failed to fetch data' });
  }
});


router.post('/equipmentAccessUser', async (req, res) => {
  const reqQuery = req.query;
  const reqBody = req.body;
  try {
    const userList = await User.find({ status: 0 }).select('firstName lastName fullName dateOfBirth gender contactNumber address position department supervisor employmentStatus  emergencyContact skills qualifications trainingHistory leaveHistory notes emailAddress countryCode mobile status role palletType');

    if (userList.length === 0) {
      return res.status(400).json({ status: -1, message: commonFunction.translate('##user not found##', reqQuery.language) });
    }
    return res.status(200).json({ status: 1, message: commonFunction.translate('##success##', reqQuery.language), responseData: userList });
  } catch (err) {

    return res.status(500).json({ status: -1, message: commonFunction.translate('##internal error##', reqQuery.language) });
  }
});



router.post('/equipmentlistByUserId', async (req, res) => {
  const reqQuery = req.query;
  const reqBody = req.body;
  try {
    const userList = await User.findOne({ _id: reqBody.userId }).select('equipmentType');

    if (!userList) {
      return res.status(400).json({ status: -1, message: commonFunction.translate('##equipment not found##', reqQuery.language) });
    }
    return res.status(200).json({ status: 1, message: commonFunction.translate('##success##', reqQuery.language), responseData: userList.equipmentType });
  } catch (err) {

    return res.status(500).json({ status: -1, message: commonFunction.translate('##internal error##', reqQuery.language) });
  }
});

router.post('/pickerUserList', async (req, res) => {
  const reqQuery = req.query;
  const reqBody = req.body;
  try {
    var query = {};
    if (reqBody.wareHouseId != undefined && reqBody.wareHouseId != "") {
      query.wareHouseId = new mongoose.Types.ObjectId(reqBody.wareHouseId);
    }
    if (reqBody.companyId != undefined && reqBody.companyId != "") {
      query.companyId = new mongoose.Types.ObjectId(reqBody.companyId);
    }
    query.status = 0;
    query['role.type'] = { $in: [6, 7, 8] };
    // console.log("query",query);
    const userList = await User.find(query).select('firstName lastName fullName dateOfBirth gender contactNumber address position department supervisor employmentStatus  emergencyContact skills qualifications trainingHistory leaveHistory notes emailAddress countryCode mobile status role palletType');
    // const userList = await User.find({status:0, "role.type": { $in: [6,7,8] } }).select('firstName lastName fullName dateOfBirth gender contactNumber address position department supervisor employmentStatus  emergencyContact skills qualifications trainingHistory leaveHistory notes emailAddress countryCode mobile status role palletType');

    if (userList.length === 0) {
      return res.status(400).json({ status: -1, message: commonFunction.translate('##user not found##', reqQuery.language) });
    }
    return res.status(200).json({ status: 1, message: commonFunction.translate('##success##', reqQuery.language), responseData: userList });
  } catch (err) {
    // console.log("err",err);
    return res.status(500).json({ status: -1, message: commonFunction.translate('##internal error##', reqQuery.language) });
  }
});

router.post('/userStatusCopy', async (req, res) => {
  const reqQuery = req.query;
  const { userId } = req.body;

  try {
    // Count the tasks for the given userId with the specified status
    const upcomingCount = await Task.countDocuments({ userId, status: 1 });
    const ongoingCount = await Task.countDocuments({ userId, status: 2 });
    const completedCount = await Task.countDocuments({ userId, status: 3 });

    const data = {
      userId,
      upcoming: upcomingCount,
      ongoing: ongoingCount,
      completed: completedCount
    };

    const response = {
      status: 1,
      message: commonFunction.translate('##success##', reqQuery.language),
      responseData: data
    };

    return res.status(200).json(response);
  } catch (error) {
    console.log(error);
    const response = {
      status: -1,
      message: commonFunction.translate('##internal error##', reqQuery.language)
    };

    return res.status(500).json(response);
  }
});

router.post('/userStatus', async (req, res) => {
  const reqQuery = req.query;
  const { userId } = req.body;

  try {
    // Get the current date in the format "YYYY-MM-DD"
    const currentDate = new Date().toISOString().split('T')[0]; // Extract the date part

    // Count the tasks for the given userId with status 1,2,3 for the current date
    const upcomingCount = await Task.countDocuments({ userId, status: 1, date: currentDate });
    const ongoingCount = await Task.countDocuments({ userId, status: 2, date: currentDate });
    const completedCount = await Task.countDocuments({ userId, status: 3, date: currentDate });

    const data = {
      userId,
      currentDate,
      upcoming: upcomingCount,
      ongoing: ongoingCount,
      completed: completedCount
    };

    const response = {
      status: 1,
      message: commonFunction.translate('##success##', reqQuery.language),
      responseData: data
    };

    return res.status(200).json(response);
  } catch (error) {
    console.log(error);
    const response = {
      status: -1,
      message: commonFunction.translate('##internal error##', reqQuery.language)
    };

    return res.status(500).json(response);
  }
});




module.exports = router;